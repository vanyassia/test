<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>–ú–∞—Å—Ç—Ö—ç–≤ –°–∞–ø—ë—Ä ‚Äî Premium</title>
<style>
/* =========================
   Variables & Themes
   ========================= */
:root{
  --bg: #f6f7fb;
  --panel: #ffffff;
  --muted: #6b7280;
  --accent: linear-gradient(180deg,#4f46e5 0%,#06b6d4 100%);
  --tile: linear-gradient(180deg,#eef2ff,#f8fafc);
  --text: #0f172a;
  --danger: #ef4444;
  --success: #10b981;
  --shadow: 0 6px 18px rgba(15,23,42,0.08);
  --glass: rgba(255,255,255,0.6);
  --cell-size: 40px; /* adjustable via JS for responsiveness */
  --ui-radius: 12px;
  --glass-2: rgba(255,255,255,0.85);
  --grid-gap: 6px;
  --font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  --ui-scale: 1;
}

/* Dark theme */
:root.dark{
  --bg: #071025;
  --panel: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
  --muted: #9ca3af;
  --accent: linear-gradient(180deg,#7c3aed,#06b6d4);
  --tile: linear-gradient(180deg,#0b1220,#071020);
  --text: #e6eef8;
  --danger: #ff6b6b;
  --success: #22c55e;
  --shadow: 0 8px 24px rgba(2,6,23,0.6);
  --glass: rgba(255,255,255,0.03);
  --glass-2: rgba(255,255,255,0.02);
}

/* Respect prefers-color-scheme by default */
@media (prefers-color-scheme: dark){
  :root:not(.light){ /* allow explicit .light override */
    --bg: #071025;
    --panel: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    --muted: #9ca3af;
    --accent: linear-gradient(180deg,#7c3aed,#06b6d4);
    --tile: linear-gradient(180deg,#0b1220,#071020);
    --text: #e6eef8;
    --danger: #ff6b6b;
    --success: #22c55e;
    --shadow: 0 8px 24px rgba(2,6,23,0.6);
    --glass: rgba(255,255,255,0.03);
    --glass-2: rgba(255,255,255,0.02);
  }
}

/* Reduced motion handling */
@media (prefers-reduced-motion: reduce){
  :root { --reduced-motion: 1; }
}

/* =========================
   Layout
   ========================= */
*{box-sizing:border-box}
html,body{
  height:100%;
  margin:0;
  font-family:var(--font-family);
  background:var(--bg);
  color:var(--text);
  -webkit-font-smoothing:antialiased;
  -moz-osx-font-smoothing:grayscale;
  font-size:16px;
}

.app {
  min-height:100vh;
  display:flex;
  align-items:center;
  justify-content:center;
  padding:24px;
  gap:20px;
}

/* Panel */
.shell{
  width:min(1200px,100%);
  background:var(--panel);
  border-radius:16px;
  box-shadow:var(--shadow);
  padding:18px;
  display:grid;
  grid-template-columns: 360px 1fr;
  gap:18px;
  align-items:start;
}

/* Left controls */
.controls{
  display:flex;
  flex-direction:column;
  gap:12px;
  min-width:220px;
}

/* Header row */
.header{
  display:flex;
  gap:10px;
  align-items:center;
  justify-content:space-between;
  margin-bottom:6px;
}

/* Stat badges */
.stats{
  display:flex;
  gap:8px;
  align-items:center;
}
.badge{
  background:var(--glass);
  padding:8px 12px;
  border-radius:12px;
  font-weight:600;
  display:flex;
  gap:8px;
  align-items:center;
  box-shadow:inset 0 -1px 0 rgba(255,255,255,0.04);
}

/* Buttons */
.btn{
  border:0;
  padding:10px 12px;
  border-radius:10px;
  background:linear-gradient(180deg,rgba(255,255,255,0.06),rgba(255,255,255,0.02));
  cursor:pointer;
  display:inline-flex;
  gap:8px;
  align-items:center;
  font-weight:600;
  transition:transform .12s ease, box-shadow .12s ease;
  user-select:none;
}
.btn:active{ transform: translateY(1px) scale(.997); }
.btn:focus{ outline:3px solid rgba(99,102,241,0.14); outline-offset:2px; }

/* Primary */
.btn.primary{
  background:var(--accent);
  color:white;
  padding:10px 14px;
  box-shadow: 0 6px 18px rgba(6,182,212,0.12);
}

/* Small inputs */
.row{
  display:flex;
  gap:8px;
  align-items:center;
}

/* Difficulty select */
.select, input[type=number], input[type=text]{
  border-radius:10px;
  border:1px solid rgba(0,0,0,0.06);
  padding:8px;
  font-size:14px;
  background:transparent;
}

/* Game area */
.play-area{
  display:flex;
  flex-direction:column;
  gap:12px;
}

/* Grid container (virtualized) */
.grid-wrap{
  background:var(--tile);
  border-radius:12px;
  padding:12px;
  display:flex;
  justify-content:center;
  align-items:center;
  min-height:200px;
  max-height:calc(80vh);
  overflow:auto;
  position:relative;
}

/* Inner grid scroller: will be sized to logical rows*cellsize */
.grid-viewport{
  position:relative;
  margin:auto;
  will-change:transform;
}

/* Visible cells are absolutely positioned inside viewport for virtualization */
.cell{
  position:absolute;
  width:var(--cell-size);
  height:var(--cell-size);
  border-radius:8px;
  display:flex;
  align-items:center;
  justify-content:center;
  font-weight:700;
  font-size:calc(var(--cell-size) * 0.42);
  user-select:none;
  transition:transform .12s ease, opacity .12s ease, box-shadow .12s ease;
  box-shadow: 0 4px 14px rgba(2,6,23,0.06);
  background: linear-gradient(180deg, rgba(255,255,255,0.8), rgba(255,255,255,0.6));
  color:var(--text);
  border:1px solid rgba(0,0,0,0.04);
  overflow:hidden;
}

/* hidden/revealed states */
.cell.revealed{
  background: linear-gradient(180deg, rgba(0,0,0,0.03), rgba(0,0,0,0.01));
  transform: translateY(1px);
  box-shadow:none;
  border:1px solid rgba(0,0,0,0.06);
}
.cell.mine{
  background: linear-gradient(180deg, rgba(255,230,230,0.98), rgba(255,248,248,0.98));
  color:var(--danger);
}

/* Flag/question markers */
.marker{
  width:60%;
  height:60%;
  display:flex;
  align-items:center;
  justify-content:center;
  pointer-events:none;
  transform-origin:center;
}

/* Animations */
@keyframes pop {
  from { transform: scale(.85); opacity:0.3 }
  to { transform: scale(1); opacity:1 }
}
.cell.revealed { animation: pop .12s ease both; }

/* Hover/active microinteractions */
.cell:focus { outline:3px solid rgba(99,102,241,0.12); outline-offset:2px; }
.cell:hover{ transform: translateY(-3px) scale(1.01); }

/* Small screens adjustments */
@media (max-width:900px){
  .shell{ grid-template-columns: 1fr; padding:12px; }
  .controls{ order:2; flex-direction:row; overflow:auto; gap:8px; }
  .play-area{ order:1; }
  :root{ --cell-size: calc(12vmin); }
}

/* Footer & records */
.records{
  background:var(--glass-2);
  padding:8px;
  border-radius:10px;
  font-size:13px;
  display:flex;
  flex-direction:column;
  gap:8px;
}

/* Accessibility helpers */
.sr-only{
  position:absolute!important;
  height:1px; width:1px;
  overflow:hidden;
  clip:rect(1px,1px,1px,1px);
  white-space:nowrap;
}

/* Replay overlay */
.replay-overlay{
  position:absolute; inset:8px; border-radius:10px; pointer-events:none;
  display:flex; align-items:center; justify-content:center; gap:12px;
}

/* Icons simple */
.icon{ width:18px; height:18px; display:inline-block; }

/* Tooltip */
.tooltip{ position:relative; }
.tooltip:hover::after{
  content:attr(data-tip);
  position:absolute; bottom:calc(100% + 8px); left:50%;
  transform:translateX(-50%); background:rgba(0,0,0,0.8);
  color:white; padding:6px 8px; border-radius:6px; font-size:12px;
  white-space:nowrap;
}

/* small helper */
.kv{ font-size:13px; color:var(--muted) }
</style>
</head>
<body>
<div class="app" id="app">
  <div class="shell" id="shell">
    <div class="controls" aria-hidden="false">
      <div class="header" role="banner">
        <div>
          <div style="font-weight:800;font-size:18px">–°–∞–ø—ë—Ä ‚Äî Premium</div>
          <div class="kv">–ù–∞–∂–º–∏—Ç–µ F —á—Ç–æ–±—ã –ø–æ—Å—Ç–∞–≤–∏—Ç—å —Ñ–ª–∞–≥. Enter/Space –æ—Ç–∫—Ä—ã—Ç—å.</div>
        </div>
        <div style="display:flex;align-items:center;gap:8px">
          <button class="btn" id="theme-toggle" aria-label="–ü–µ—Ä–µ–∫–ª—é—á–∏—Ç—å —Ç–µ–º—É" title="–¢–µ–º–∞ (T)">
            <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
          </button>
          <button class="btn" id="dev-toggle" title="Dev tools (Ctrl+Shift+D)"><svg class="icon" viewBox="0 0 24 24"><path d="M10 17l5-5-5-5v10z"/></svg></button>
        </div>
      </div>

      <div style="display:flex;flex-direction:column;gap:8px">
        <div class="row">
          <select id="difficulty" class="select" aria-label="–°–ª–æ–∂–Ω–æ—Å—Ç—å" title="–°–ª–æ–∂–Ω–æ—Å—Ç—å">
            <option value="beginner">–ù–æ–≤–∏—á–æ–∫ (9√ó9,10)</option>
            <option value="intermediate">–õ—é–±–∏—Ç–µ–ª—å (16√ó16,40)</option>
            <option value="expert">–ü—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª (16√ó30,99)</option>
            <option value="custom">–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π</option>
          </select>
          <button class="btn primary" id="new-game" aria-label="–ù–æ–≤–∞—è –∏–≥—Ä–∞">–ù–æ–≤–∞—è –∏–≥—Ä–∞</button>
        </div>

        <div class="row">
          <label class="kv">–†—è–¥—ã <input id="rows" type="number" min="5" max="200" value="9" style="width:80px"></label>
          <label class="kv">–°—Ç–æ–ª–±—Ü—ã <input id="cols" type="number" min="5" max="200" value="9" style="width:80px"></label>
          <label class="kv">–ú–∏–Ω—ã <input id="mines" type="number" min="1" max="3000" value="10" style="width:80px"></label>
        </div>

        <div style="display:flex;gap:8px;align-items:center">
          <div class="badge" id="time">00:00</div>
          <div class="badge" id="mines-left">M: 10</div>
          <button class="btn" id="pause">–ü–∞—É–∑–∞</button>
          <button class="btn" id="hint" title="–ü–æ–¥—Å–∫–∞–∑–∫–∞ (–ø–æ–¥—Å–≤–µ—á–∏–≤–∞–µ—Ç –±–µ–∑–æ–ø–∞—Å–Ω—É—é –∫–ª–µ—Ç–∫—É)">–ü–æ–¥—Å–∫–∞–∑–∫–∞</button>
        </div>

        <div style="display:flex;gap:8px">
          <button class="btn" id="toggle-sound" title="–ó–≤—É–∫">üîä</button>
          <button class="btn" id="export-url" title="–≠–∫—Å–ø–æ—Ä—Ç –∏–≥—Ä—ã –≤ URL">–°—Å—ã–ª–∫–∞</button>
          <button class="btn" id="save-game" title="–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏–≥—Ä—É">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
        </div>

        <div class="records" style="margin-top:6px">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <div style="font-weight:700">–†–µ–∫–æ—Ä–¥—ã</div>
            <div style="display:flex;gap:6px">
              <button class="btn" id="export-records">–≠–∫—Å–ø–æ—Ä—Ç</button>
              <button class="btn" id="import-records">–ò–º–ø–æ—Ä—Ç</button>
              <button class="btn" id="clear-storage">–û—á–∏—Å—Ç–∏—Ç—å</button>
            </div>
          </div>
          <div id="records-list" style="display:flex;flex-direction:column;gap:6px;max-height:200px;overflow:auto;font-size:13px"></div>
        </div>

        <div style="margin-top:6px;font-size:13px;color:var(--muted)">
          –Ø–∑—ã–∫–∏:
          <button class="btn" id="lang-ru">RU</button>
          <button class="btn" id="lang-en">EN</button>
        </div>
      </div>
    </div>

    <div class="play-area" role="main">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div style="display:flex;gap:8px;align-items:center">
          <button class="btn" id="smiley" aria-live="polite" aria-atomic="true" title="–ù–æ–≤–∞—è –∏–≥—Ä–∞">üôÇ</button>
          <div class="kv" id="status-text" aria-live="polite">–ì–æ—Ç–æ–≤ –∫ –∏–≥—Ä–µ</div>
        </div>
        <div style="display:flex;gap:8px;align-items:center">
          <div class="kv">–ù–∞–≤–∏–≥–∞—Ü–∏—è: —Å—Ç—Ä–µ–ª–∫–∏</div>
          <div class="kv">–§–ª–∞–≥–∏: –ø—Ä–∞–≤–∞—è –∫–Ω–æ–ø–∫–∞ / F</div>
        </div>
      </div>

      <div class="grid-wrap" id="grid-wrap" role="application" aria-label="–ò–≥—Ä–æ–≤–æ–µ –ø–æ–ª–µ">
        <div class="grid-viewport" id="grid-viewport" role="grid" aria-readonly="false"></div>
        <div class="replay-overlay" id="replay-overlay" aria-hidden="true"></div>
      </div>

      <div style="display:flex;justify-content:space-between;gap:8px;align-items:center;margin-top:6px">
        <div class="kv">–ü–æ–¥—Å–∫–∞–∑–∫–∏: <span id="hints-left">3</span></div>
        <div style="display:flex;gap:8px">
          <button class="btn" id="replay">–†–µ–ø–ª–µ–π</button>
          <button class="btn" id="dev-selftest">Self-test</button>
        </div>
      </div>
    </div>

  </div>
</div>

<!-- ARIA live region for important status -->
<div class="sr-only" aria-live="polite" id="aria-live" role="status"></div>

<script>
/* ============================================================================
   PREMIUM MINESWEEPER ‚Äî single-file app
   ES2020+ structured with classes and IIFE patterns.
   - Hybrid approach: DOM-grid with virtualization (only visible cells rendered).
   - Accessibility: semantic roles, keyboard support, aria-live.
   - Performance: iterative flood-fill, batched DOM updates, virtualization window.
   - Storage: versioned localStorage keys. No external network usage.
   ============================================================================ */

(() => {
  'use strict';

  /* --------------------
     Translations (i18n)
     -------------------- */
  const LOCALES = {
    ru: {
      ready: '–ì–æ—Ç–æ–≤ –∫ –∏–≥—Ä–µ',
      lost: '–í—ã –ø—Ä–æ–∏–≥—Ä–∞–ª–∏',
      won: '–ü–æ–±–µ–¥–∞! –í—Ä–µ–º—è: {t}s',
      minesLeft: 'M: {n}',
      hintUsed: '–ü–æ–¥—Å–∫–∞–∑–∫–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∞',
      saved: '–ò–≥—Ä–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞',
      loaded: '–ò–≥—Ä–∞ –∑–∞–≥—Ä—É–∂–µ–Ω–∞',
      exportSuccess: 'URL —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω –≤ –±—É—Ñ–µ—Ä',
      invalidImport: '–ù–µ–≤–µ—Ä–Ω—ã–π –∏–º–ø–æ—Ä—Ç'
    },
    en: {
      ready: 'Ready',
      lost: 'You lost',
      won: 'Victory! Time: {t}s',
      minesLeft: 'M: {n}',
      hintUsed: 'Hint used',
      saved: 'Game saved',
      loaded: 'Game loaded',
      exportSuccess: 'URL copied',
      invalidImport: 'Invalid import'
    }
  };
  let locale = 'ru';
  function t(key, vars={}) {
    const s = (LOCALES[locale] && LOCALES[locale][key]) || LOCALES['en'][key] || key;
    return s.replace(/\{(\w+)\}/g, (_,k)=>vars[k] ?? '');
  }

  /* --------------------
     Constants & Storage
     -------------------- */
  const STORAGE_PREFIX = 'mswp_v1'; // versioned key prefix
  const STORAGE_GAME = STORAGE_PREFIX + '_game';
  const STORAGE_RECORDS = STORAGE_PREFIX + '_records';
  const DEFAULT_HINTS = 3;
  const SOUND_ON_DEFAULT = true;

  /* --------------------
     Utilities
     -------------------- */
  const el = (sel)=>document.querySelector(sel);
  const elAll = (sel)=>Array.from(document.querySelectorAll(sel));
  const randInt = (min,max)=>Math.floor(Math.random()*(max-min+1))+min;
  const clamp = (v,a,b)=>Math.min(Math.max(v,a),b);
  const now = ()=>Date.now();

  /* --------------------
     Simple Base64 beep for minimal audio feedback
     (short data URIs)
     -------------------- */
  const SOUNDS = {
    tick: "data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAIlYAAESsAAACABAAZGF0YQAAAAA=",
    boom: "data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAIlYAAESsAAACABAAZGF0YQAAAAA="
  };

  class AudioPlayer {
    constructor(){ this.enabled = SOUND_ON_DEFAULT; }
    play(name){
      if(!this.enabled) return;
      try{
        const a = new Audio(SOUNDS[name] || SOUNDS.tick);
        a.volume = 0.12;
        a.play().catch(()=>{});
      }catch(e){}
    }
  }

  /* --------------------
     Game Logic
     -------------------- */
  class MinesGame {
    constructor(rows=9,cols=9,mines=10){
      this.rows = rows; this.cols = cols; this.minesCount = mines;
      this.size = rows*cols;
      this.reset();
    }
    reset(){
      // Logical grid stored as typed arrays for performance
      this.mined = new Uint8Array(this.size);      // 1 if mine
      this.revealed = new Uint8Array(this.size);   // 1 if revealed
      this.flagged = new Uint8Array(this.size);    // 0 none,1 flag,2 question
      this.neighbors = new Uint8Array(this.size);  // neighbor mine counts
      this.firstClick = true;
      this.startTime = null;
      this.elapsed = 0;
      this.hintsLeft = DEFAULT_HINTS;
      this.moveLog = []; // for replay
      this.state = 'ready'; // 'playing','lost','won','paused'
    }

    index(r,c){ return r*this.cols + c; }
    rc(i){ return [Math.floor(i/this.cols), i%this.cols]; }
    inBounds(r,c){ return r>=0 && c>=0 && r<this.rows && c<this.cols; }

    // Place mines avoiding a specific index (first click).
    placeMines(avoidIndex){
      // generate list of candidate indices
      const candidates = [];
      for(let i=0;i<this.size;i++){
        if(i===avoidIndex) continue;
        candidates.push(i);
      }
      // Fisher-Yates partial shuffle to pick minesCount unique indices
      for(let i=0;i<this.minesCount;i++){
        const j = i + Math.floor(Math.random()*(candidates.length-i));
        [candidates[i], candidates[j]] = [candidates[j], candidates[i]];
      }
      // mark mines
      for(let k=0;k<this.minesCount;k++){
        const idx = candidates[k];
        this.mined[idx]=1;
      }
      // compute neighbor counts iteratively
      for(let r=0;r<this.rows;r++){
        for(let c=0;c<this.cols;c++){
          const i = this.index(r,c);
          if(this.mined[i]){ this.neighbors[i]=255; continue; }
          let count=0;
          for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){
            if(dr===0 && dc===0) continue;
            const nr=r+dr, nc=c+dc;
            if(this.inBounds(nr,nc) && this.mined[this.index(nr,nc)]) count++;
          }
          this.neighbors[i]=count;
        }
      }
    }

    // Iterative flood fill reveal for zeros; returns list of revealed indices
    revealIndex(i){
      if(this.revealed[i] || this.flagged[i]) return [];
      const revealedNow = [];
      const stack = [i];
      while(stack.length){
        const cur = stack.pop();
        if(this.revealed[cur] || this.flagged[cur]) continue;
        this.revealed[cur]=1;
        revealedNow.push(cur);
        if(this.neighbors[cur]===0){
          const [r,c] = this.rc(cur);
          for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){
            if(dr===0 && dc===0) continue;
            const nr = r+dr, nc = c+dc;
            if(this.inBounds(nr,nc)){
              const ni = this.index(nr,nc);
              if(!this.revealed[ni] && !this.flagged[ni]) stack.push(ni);
            }
          }
        }
      }
      return revealedNow;
    }

    // Open cell triggered
    open(i){
      if(this.state==='lost' || this.state==='won' || this.state==='paused') return {status:'ignored'};
      if(this.firstClick){
        this.placeMines(i);
        this.firstClick=false;
        this.state='playing';
        this.startTime = now();
      }
      this.moveLog.push({t:now(), action:'open', idx:i});
      if(this.mined[i]){
        this.revealed[i]=1;
        this.state='lost';
        return {status:'boom', idx:i};
      } else {
        const revealed = this.revealIndex(i);
        // check win
        const totalRevealed = this.revealed.reduce((a,b)=>a+b,0);
        if(totalRevealed === this.size - this.minesCount){
          this.state='won';
          this.elapsed = Math.floor(((now() - this.startTime)/1000) || 0);
          return {status:'win', revealed};
        }
        return {status:'ok', revealed};
      }
    }

    toggleFlag(i){
      if(this.state==='lost' || this.state==='won') return;
      // cycle: 0 -> 1(flag) -> 2(question) -> 0
      this.flagged[i] = (this.flagged[i] + 1) % 3;
      this.moveLog.push({t:now(), action:'flag', idx:i, state:this.flagged[i]});
    }

    // Reveal all mines on loss
    revealAllMines(){
      const mines = [];
      for(let i=0;i<this.size;i++) if(this.mined[i]) mines.push(i);
      for(const i of mines) this.revealed[i]=1;
      return mines;
    }

    hintsAvailable(){ return this.hintsLeft > 0; }

    useHint(){
      // pick a safe unrevealed, unflagged cell
      for(let i=0;i<this.size;i++){
        if(!this.mined[i] && !this.revealed[i] && !this.flagged[i]){
          this.hintsLeft--;
          this.moveLog.push({t:now(), action:'hint', idx:i});
          return i;
        }
      }
      return -1;
    }

    toJSON(){
      // serialize minimal necessary state
      return {
        rows:this.rows, cols:this.cols, minesCount:this.minesCount,
        mined:Array.from(this.mined),
        revealed:Array.from(this.revealed),
        flagged:Array.from(this.flagged),
        neighbors:Array.from(this.neighbors),
        firstClick:this.firstClick, startTime:this.startTime, elapsed:this.elapsed,
        hintsLeft:this.hintsLeft,
        state:this.state,
        moveLog:this.moveLog
      };
    }

    static fromJSON(obj){
      const g = new MinesGame(obj.rows, obj.cols, obj.minesCount);
      g.mined = Uint8Array.from(obj.mined);
      g.revealed = Uint8Array.from(obj.revealed);
      g.flagged = Uint8Array.from(obj.flagged);
      g.neighbors = Uint8Array.from(obj.neighbors);
      g.firstClick = obj.firstClick;
      g.startTime = obj.startTime;
      g.elapsed = obj.elapsed;
      g.hintsLeft = obj.hintsLeft ?? DEFAULT_HINTS;
      g.state = obj.state ?? 'ready';
      g.moveLog = obj.moveLog ?? [];
      return g;
    }
  }

  /* --------------------
     Virtualized Grid Renderer + UI Controller
     - Renders only visible cells based on scroll/viewport.
     - Accessible: each cell is a button with role=gridcell when visible.
     -------------------- */
  class UI {
    constructor() {
      // DOM refs
      this.gridWrap = el('#grid-wrap');
      this.gridViewport = el('#grid-viewport');
      this.timeEl = el('#time');
      this.minesLeftEl = el('#mines-left');
      this.statusText = el('#status-text');
      this.ariaLive = el('#aria-live');
      this.recordsList = el('#records-list');
      this.hintsEl = el('#hints-left');
      this.replayOverlay = el('#replay-overlay');
      this.audio = new AudioPlayer();

      // app state
      this.game = new MinesGame();
      this.cellCache = new Map(); // cache DOM nodes for reuse
      this.visibleCells = new Set();
      this.viewport = {top:0,left:0,width:0,height:0};
      this.cellSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell-size')) || 40;
      this.overscan = 2; // extra rows/cols to render outside viewport
      this.timerHandle = null;
      this.records = []; // list of {name,time,date,mode}
      this.replayIdx = 0;
      this.replayPlaying = false;
      this.soundOn = true;

      // bind events
      this.bindControls();
      this.applyDifficulty('beginner');
      this.renderRecords();
      this.renderGrid();
      this.loadSavedGameIfAny();
      this.applyThemeFromPref();
      this.updateUI();
    }

    bindControls(){
      el('#new-game').addEventListener('click', ()=>this.startNewGame());
      el('#difficulty').addEventListener('change',(e)=>this.onDifficultyChange(e.target.value));
      el('#rows').addEventListener('change', ()=>this.onCustomChange());
      el('#cols').addEventListener('change', ()=>this.onCustomChange());
      el('#mines').addEventListener('change', ()=>this.onCustomChange());
      this.gridWrap.addEventListener('scroll', ()=>this.onScroll());
      window.addEventListener('resize', ()=>this.onScroll());
      el('#grid-viewport').addEventListener('click', (e)=>this.onCellClick(e));
      el('#grid-viewport').addEventListener('contextmenu', (e)=>this.onCellRightClick(e));
      el('#hint').addEventListener('click', ()=>this.onHint());
      el('#pause').addEventListener('click', ()=>this.togglePause());
      el('#toggle-sound').addEventListener('click', ()=>{ this.soundOn = !this.soundOn; this.audio.enabled = this.soundOn; el('#toggle-sound').textContent = this.soundOn ? 'üîä' : 'üîá'; });
      el('#theme-toggle').addEventListener('click', ()=>this.toggleTheme());
      el('#lang-ru').addEventListener('click', ()=>{locale='ru'; this.updateUI();});
      el('#lang-en').addEventListener('click', ()=>{locale='en'; this.updateUI();});
      el('#export-url').addEventListener('click', ()=>this.exportToURL());
      el('#save-game').addEventListener('click', ()=>this.saveGame());
      el('#export-records').addEventListener('click', ()=>this.exportRecords());
      el('#import-records').addEventListener('click', ()=>this.importRecords());
      el('#clear-storage').addEventListener('click', ()=>this.clearStorage());
      el('#replay').addEventListener('click', ()=>this.playReplay());
      el('#dev-selftest').addEventListener('click', ()=>this.selfTest());

      // keyboard navigation + global shortcuts
      window.addEventListener('keydown', (e)=>this.onKey(e));
      // long-press touch for flags
      this.setupTouchHandlers();

      // dev toggle
      el('#dev-toggle').addEventListener('click', ()=>this.toggleDev());
      window.addEventListener('keydown', (e)=>{ if(e.ctrlKey && e.shiftKey && e.code==='KeyD'){ this.toggleDev(); } });

      // import URL fragment if present
      setTimeout(()=>this.importFromURLFragment(),0);
    }

    /* --------------------
       Adaptive UI & Grid sizing
       -------------------- */
    applyDifficulty(mode){
      const r=el('#rows'), c=el('#cols'), m=el('#mines');
      if(mode==='beginner'){ r.value=9; c.value=9; m.value=10; }
      if(mode==='intermediate'){ r.value=16; c.value=16; m.value=40; }
      if(mode==='expert'){ r.value=16; c.value=30; m.value=99; }
      if(mode==='custom'){ /* keep as-is */ }
      this.onCustomChange();
    }
    onDifficultyChange(val){ this.applyDifficulty(val); }
    onCustomChange(){
      const rows = clamp(parseInt(el('#rows').value||9),5,200);
      const cols = clamp(parseInt(el('#cols').value||9),5,200);
      let mines = parseInt(el('#mines').value||10);
      const maxMines = Math.max(1, Math.floor(rows*cols - 1));
      mines = clamp(mines,1,maxMines);
      el('#mines').value = mines;
      el('#rows').value = rows;
      el('#cols').value = cols;
      this.cellSize = Math.max(20, Math.min(64, Math.floor((Math.min(window.innerWidth,window.innerHeight))/Math.max(rows,cols))));
      document.documentElement.style.setProperty('--cell-size', this.cellSize + 'px');
      this.renderGrid(true);
    }

    applyThemeFromPref(){
      // respect explicit class if previously toggled
      const root = document.documentElement;
      const pref = localStorage.getItem(STORAGE_PREFIX + '_theme');
      if(pref) root.className = pref;
      // if nothing, prefers-color-scheme handled by CSS
    }
    toggleTheme(){
      const root = document.documentElement;
      if(root.classList.contains('dark')){ root.classList.remove('dark'); root.classList.add('light'); localStorage.setItem(STORAGE_PREFIX + '_theme','light'); }
      else { root.classList.remove('light'); root.classList.add('dark'); localStorage.setItem(STORAGE_PREFIX + '_theme','dark'); }
    }

    /* --------------------
       Grid rendering & virtualization
       -------------------- */
    renderGrid(recreate=false){
      const rows = parseInt(el('#rows').value);
      const cols = parseInt(el('#cols').value);
      const mines = parseInt(el('#mines').value);

      if(recreate || !this.game || this.game.rows!==rows || this.game.cols!==cols || this.game.minesCount!==mines){
        this.game = new MinesGame(rows,cols,mines);
        this.cellCache.clear();
        this.visibleCells.clear();
        this.gridViewport.innerHTML = '';
        // set viewport logical size
        this.gridViewport.style.width = (cols * this.cellSize) + 'px';
        this.gridViewport.style.height = (rows * this.cellSize) + 'px';
      }
      // ensure we render visible cells
      this.onScroll();
      this.updateUI();
    }

    onScroll(){
      // Determine visible rows/cols based on scroll position and viewport
      const wrap = this.gridWrap;
      const rect = wrap.getBoundingClientRect();
      const viewLeft = wrap.scrollLeft;
      const viewTop = wrap.scrollTop;
      const viewWidth = rect.width;
      const viewHeight = rect.height;

      const startCol = Math.floor(viewLeft / this.cellSize) - this.overscan;
      const endCol = Math.ceil((viewLeft + viewWidth) / this.cellSize) + this.overscan;
      const startRow = Math.floor(viewTop / this.cellSize) - this.overscan;
      const endRow = Math.ceil((viewTop + viewHeight) / this.cellSize) + this.overscan;

      const rows = this.game.rows, cols = this.game.cols;

      const newVisible = new Set();
      for(let r = clamp(startRow,0,rows-1); r<=clamp(endRow,0,rows-1); r++){
        for(let c = clamp(startCol,0,cols-1); c<=clamp(endCol,0,cols-1); c++){
          newVisible.add(this.game.index(r,c));
        }
      }

      // remove nodes not visible
      for(const idx of this.visibleCells){
        if(!newVisible.has(idx)){
          const n = this.cellCache.get(idx);
          if(n && n.parentElement) n.parentElement.removeChild(n);
          this.cellCache.delete(idx);
        }
      }

      // add new visible nodes
      for(const idx of newVisible){
        if(!this.cellCache.has(idx)){
          const node = this.createCellNode(idx);
          this.cellCache.set(idx, node);
          this.gridViewport.appendChild(node);
        } else {
          // update existing node position/state
          const node = this.cellCache.get(idx);
          this.updateCellNode(node, idx);
        }
      }

      this.visibleCells = newVisible;
    }

    createCellNode(idx){
      const node = document.createElement('button');
      node.className = 'cell';
      node.setAttribute('data-idx', idx);
      node.style.width = this.cellSize + 'px';
      node.style.height = this.cellSize + 'px';
      node.style.left = ((idx % this.game.cols) * this.cellSize) + 'px';
      node.style.top = (Math.floor(idx / this.game.cols) * this.cellSize) + 'px';
      node.setAttribute('role','gridcell');
      node.setAttribute('tabindex','-1');
      node.addEventListener('contextmenu', (e)=>{ e.preventDefault(); this.handleFlagFromNode(idx); });
      node.addEventListener('click', ()=>this.handleOpenFromNode(idx));
      node.addEventListener('keydown', (e)=>this.onCellKey(e, idx));
      node.addEventListener('focus', ()=>{ node.classList.add('focused'); });
      node.addEventListener('blur', ()=>{ node.classList.remove('focused'); });
      this.updateCellNode(node, idx);
      return node;
    }

    updateCellNode(node, idx){
      // position & content & ARIA
      const [r,c] = this.game.rc(idx);
      node.style.left = (c * this.cellSize) + 'px';
      node.style.top = (r * this.cellSize) + 'px';
      const revealed = this.game.revealed[idx];
      const flagged = this.game.flagged[idx];
      node.classList.toggle('revealed', !!revealed);
      node.classList.toggle('mine', !!(revealed && this.game.mined[idx]));
      node.innerHTML = '';

      // Accessible label
      let label = `R${r+1}C${c+1}. `;
      if(revealed){
        if(this.game.mined[idx]) label += 'Mine.';
        else label += `Neighbours ${this.game.neighbors[idx]}.`;
      } else {
        if(flagged===1) label += 'Flagged.';
        else if(flagged===2) label += 'Questioned.';
        else label += 'Hidden.';
      }
      node.setAttribute('aria-label', label);

      if(!revealed){
        // show marker if flagged/question
        if(flagged===1){
          node.innerHTML = `<span class="marker" aria-hidden="true">üö©</span>`;
        } else if(flagged===2){
          node.innerHTML = `<span class="marker" aria-hidden="true">?</span>`;
        } else {
          node.innerHTML = `<span class="marker" aria-hidden="true"></span>`;
        }
      } else {
        if(this.game.mined[idx]){
          node.innerHTML = `<span class="marker" aria-hidden="true">üí£</span>`;
        } else {
          const n = this.game.neighbors[idx];
          node.innerHTML = `<span class="marker" aria-hidden="true" style="color:${this.colorForNumber(n)}">${n>0? n : ''}</span>`;
        }
      }
    }
    colorForNumber(n){
      const map = ['#000','#1976d2','#2e7d32','#b71c1c','#4510a5','#00695c','#0b5456','#333','#666'];
      return map[n] || '#222';
    }

    /* --------------------
       Handlers for cell events (open/flag)
       -------------------- */
    handleOpenFromNode(idx){
      // open cell
      const res = this.game.open(idx);
      if(res.status==='boom'){
        this.audio.play('boom');
        const mines = this.game.revealAllMines();
        // update visible nodes
        for(const i of this.visibleCells) if(this.cellCache.has(i)) this.updateCellNode(this.cellCache.get(i), i);
        this.updateUI(true);
        this.announce(t('lost'));
      } else if(res.status==='win'){
        this.audio.play('tick');
        // update nodes
        for(const i of this.visibleCells) if(this.cellCache.has(i)) this.updateCellNode(this.cellCache.get(i), i);
        this.endGame(true);
      } else if(res.status==='ok'){
        // batch update visible nodes
        for(const i of res.revealed){
          if(this.cellCache.has(i)) this.updateCellNode(this.cellCache.get(i), i);
        }
        this.audio.play('tick');
      }
      this.updateUI();
    }

    handleFlagFromNode(idx){
      this.game.toggleFlag(idx);
      if(this.cellCache.has(idx)) this.updateCellNode(this.cellCache.get(idx), idx);
      this.updateUI();
    }

    onCellClick(e){
      // click on viewport ‚Äî find nearest cell
      const target = e.target.closest('.cell');
      if(!target) return;
      const idx = parseInt(target.getAttribute('data-idx'));
      if(e.button === 2){ // right click handled separately by contextmenu
        this.handleFlagFromNode(idx);
      } else {
        this.handleOpenFromNode(idx);
      }
    }

    onCellRightClick(e){
      e.preventDefault();
      const target = e.target.closest('.cell');
      if(!target) return;
      const idx = parseInt(target.getAttribute('data-idx'));
      this.handleFlagFromNode(idx);
    }

    /* --------------------
       Keyboard / navigation
       -------------------- */
    onKey(e){
      if(document.activeElement && document.activeElement.tagName === 'INPUT') return;
      // shortcuts
      if(e.key === 'F' || e.key === 'f'){ e.preventDefault(); this.handleFlagFromNode(this.focusedIndex || 0); return; }
      if(e.key === 't' || e.key === 'T'){ if(e.altKey) return; el('#theme-toggle').click(); }
      if(e.key === 'n' || e.key === 'N'){ if(e.ctrlKey||e.metaKey) { e.preventDefault(); this.startNewGame(); } }
      if(e.key === 'Escape'){ this.togglePause(true); }
      // navigation arrows move a logical focus
      const rows = this.game.rows, cols = this.game.cols;

      if(!this.focusedIndex) this.focusedIndex = 0;
      let [r,c] = this.game.rc(this.focusedIndex);
      let moved=false;
      if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' ' ,'Enter'].includes(e.key)){
        e.preventDefault();
      }
      switch(e.key){
        case 'ArrowUp': if(r>0){ r--; moved=true; } break;
        case 'ArrowDown': if(r<rows-1){ r++; moved=true; } break;
        case 'ArrowLeft': if(c>0){ c--; moved=true; } break;
        case 'ArrowRight': if(c<cols-1){ c++; moved=true; } break;
        case 'Enter':
        case ' ':
          this.handleOpenFromNode(this.focusedIndex); return;
        case 'F':
        case 'f':
          this.handleFlagFromNode(this.focusedIndex); return;
      }
      if(moved){
        this.focusedIndex = this.game.index(r,c);
        this.focusCell(this.focusedIndex);
      }
    }

    onCellKey(e, idx){
      if(e.key==='Enter' || e.key===' ') { e.preventDefault(); this.handleOpenFromNode(idx); }
      if(e.key==='f' || e.key==='F'){ e.preventDefault(); this.handleFlagFromNode(idx); }
    }

    focusCell(idx){
      // ensure cell rendered and scroll into view
      const [r,c] = this.game.rc(idx);
      const left = c * this.cellSize, top = r * this.cellSize;
      const wrap = this.gridWrap;
      const pad = this.cellSize * 2;
      if(left < wrap.scrollLeft + pad) wrap.scrollLeft = Math.max(0, left - pad);
      if(left + this.cellSize > wrap.scrollLeft + wrap.clientWidth - pad) wrap.scrollLeft = Math.min(this.gridViewport.clientWidth, left - wrap.clientWidth + this.cellSize + pad);
      if(top < wrap.scrollTop + pad) wrap.scrollTop = Math.max(0, top - pad);
      if(top + this.cellSize > wrap.scrollTop + wrap.clientHeight - pad) wrap.scrollTop = Math.min(this.gridViewport.clientHeight, top - wrap.clientHeight + this.cellSize + pad);
      // ensure rendering done
      this.onScroll();
      const node = this.cellCache.get(idx);
      if(node){
        node.focus();
      }
    }

    /* --------------------
       Game lifecycle & UI updates
       -------------------- */
    startNewGame(){
      const rows = parseInt(el('#rows').value);
      const cols = parseInt(el('#cols').value);
      const mines = parseInt(el('#mines').value);
      this.game = new MinesGame(rows,cols,mines);
      this.gridViewport.style.width = (cols * this.cellSize) + 'px';
      this.gridViewport.style.height = (rows * this.cellSize) + 'px';
      this.cellCache.clear();
      this.gridViewport.innerHTML = '';
      this.visibleCells.clear();
      this.onScroll();
      this.clearTimer();
      this.updateUI(true);
      this.announce(t('ready'));
    }

    updateUI(force=false){
      // timer
      if(this.game.state === 'playing'){
        if(!this.timerHandle){ this.timerHandle = setInterval(()=>this.tick(), 500); }
      } else {
        if(this.timerHandle && !force) { clearInterval(this.timerHandle); this.timerHandle = null; }
      }
      // update time text
      const elapsed = this.game.startTime ? Math.floor(((now() - this.game.startTime)/1000) + (this.game.elapsed || 0)) : (this.game.elapsed || 0);
      const mm = String(Math.floor(elapsed/60)).padStart(2,'0');
      const ss = String(elapsed%60).padStart(2,'0');
      this.timeEl.textContent = `${mm}:${ss}`;

      // mines left = total mines - flags
      const flags = this.game.flagged.reduce((a,b)=>a + (b===1?1:0),0);
      const left = Math.max(0, this.game.minesCount - flags);
      this.minesLeftEl.textContent = `M: ${left}`;
      this.hintsEl.textContent = String(this.game.hintsLeft);

      // update status
      let status = t('ready');
      if(this.game.state==='playing') status = `–ò–≥—Ä–∞ –∏–¥–µ—Ç`;
      if(this.game.state==='lost') status = t('lost');
      if(this.game.state==='won') status = t('won',{t:this.game.elapsed});
      this.statusText.textContent = status;
      el('#smiley').textContent = this.game.state==='lost' ? '‚ò†Ô∏è' : (this.game.state==='won' ? 'üòé' : 'üôÇ');

      // update visible nodes
      for(const i of this.visibleCells) {
        const node = this.cellCache.get(i);
        if(node) this.updateCellNode(node, i);
      }
      // update records list
      this.renderRecords();
    }

    tick(){
      this.updateUI();
    }

    clearTimer(){ if(this.timerHandle){ clearInterval(this.timerHandle); this.timerHandle = null; } }

    endGame(won=false){
      this.clearTimer();
      if(won){
        this.audio.play('tick');
        const entry = {name: prompt('–í–≤–µ–¥–∏—Ç–µ –∏–º—è (–∫–æ—Ä–æ—Ç–∫–æ–µ):','–ò–≥—Ä–æ–∫') || '–ò–≥—Ä–æ–∫', time: this.game.elapsed || 0, date: new Date().toISOString(), mode: `${this.game.rows}x${this.game.cols} ${this.game.minesCount}`};
        this.records.push(entry);
        this.saveRecords();
      } else {
        this.audio.play('boom');
      }
      this.updateUI(true);
    }

    announce(msg){
      this.ariaLive.textContent = msg;
    }

    /* --------------------
       Hints
       -------------------- */
    onHint(){
      if(!this.game.hintsLeft){ this.announce('No hints'); return; }
      const idx = this.game.useHint();
      if(idx>=0){
        // highlight the cell briefly (flash)
        this.onScroll();
        const node = this.cellCache.get(idx);
        if(node){
          node.classList.add('hinted');
          node.animate([{transform:'scale(1.05)'},{transform:'scale(1)'}], {duration:500, easing:'ease-out'});
          setTimeout(()=>node.classList.remove('hinted'), 800);
        } else {
          // if not visible, scroll to it and then highlight
          this.focusCell(idx);
          setTimeout(()=>{ const n=this.cellCache.get(idx); if(n) n.animate([{transform:'scale(1.05)'},{transform:'scale(1)'}],{duration:400}); }, 250);
        }
        this.audio.play('tick');
        this.announce(t('hintUsed'));
        this.updateUI();
      } else {
        this.announce('No safe cell');
      }
    }

    /* --------------------
       Saving / Loading / Export
       -------------------- */
    saveGame(){
      const data = JSON.stringify(this.game.toJSON());
      localStorage.setItem(STORAGE_GAME, data);
      this.announce(t('saved'));
    }
    loadGame(){
      const raw = localStorage.getItem(STORAGE_GAME);
      if(!raw) return false;
      try{
        const obj = JSON.parse(raw);
        this.game = MinesGame.fromJSON(obj);
        el('#rows').value = this.game.rows;
        el('#cols').value = this.game.cols;
        el('#mines').value = this.game.minesCount;
        this.gridViewport.style.width = (this.game.cols * this.cellSize) + 'px';
        this.gridViewport.style.height = (this.game.rows * this.cellSize) + 'px';
        this.onScroll();
        this.updateUI(true);
        this.announce(t('loaded'));
        return true;
      }catch(e){ console.warn('load error',e); return false; }
    }
    loadSavedGameIfAny(){
      this.loadGame();
    }

    exportToURL(){
      // small compressed state: rows,cols,mines, mined indices, revealed indices, flags
      const payload = {
        rows:this.game.rows, cols:this.game.cols, minesCount:this.game.minesCount,
        mined: Array.from(this.game.mined).map((v,i)=>v?i:null).filter(v=>v!==null),
        revealed: Array.from(this.game.revealed).map((v,i)=>v?i:null).filter(v=>v!==null),
        flagged: Array.from(this.game.flagged).map((v,i)=>v?{i,st:v}:null).filter(v=>v!==null)
      };
      const text = btoa(unescape(encodeURIComponent(JSON.stringify(payload))));
      const url = location.origin + location.pathname + '#g=' + text;
      navigator.clipboard?.writeText(url).then(()=>this.announce(t('exportSuccess'))).catch(()=>{ prompt('Copy URL:', url); });
    }

    importFromURLFragment(){
      const frag = location.hash;
      if(!frag || !frag.startsWith('#g=')) return;
      try{
        const text = decodeURIComponent(escape(atob(frag.slice(3))));
        const obj = JSON.parse(text);
        const g = new MinesGame(obj.rows,obj.cols,obj.minesCount);
        for(const i of obj.mined) g.mined[i]=1;
        for(const i of obj.revealed) g.revealed[i]=1;
        for(const f of obj.flagged) g.flagged[f.i]=f.st;
        // compute neighbors
        for(let r=0;r<g.rows;r++) for(let c=0;c<g.cols;c++){
          const i = g.index(r,c);
          if(g.mined[i]) { g.neighbors[i]=255; continue; }
          let cnt=0;
          for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){
            if(dr===0 && dc===0) continue;
            const nr=r+dr, nc=c+dc;
            if(g.inBounds(nr,nc) && g.mined[g.index(nr,nc)]) cnt++;
          }
          g.neighbors[i]=cnt;
        }
        this.game = g;
        el('#rows').value = g.rows;
        el('#cols').value = g.cols;
        el('#mines').value = g.minesCount;
        this.gridViewport.style.width = (g.cols * this.cellSize) + 'px';
        this.gridViewport.style.height = (g.rows * this.cellSize) + 'px';
        this.onScroll(); this.updateUI(true);
      }catch(e){}
    }

    exportRecords(){
      const data = JSON.stringify(this.records, null, 2);
      const blob = new Blob([data], {type:'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'mines_records.json'; a.click();
      URL.revokeObjectURL(url);
    }
    importRecords(){
      const input = document.createElement('input');
      input.type='file';
      input.accept='application/json';
      input.onchange = async (e)=>{
        const file = e.target.files[0];
        if(!file) return;
        const text = await file.text();
        try{
          const arr = JSON.parse(text);
          if(Array.isArray(arr)){ this.records = arr; this.saveRecords(); this.renderRecords(); }
          else alert(t('invalidImport'));
        }catch(e){ alert(t('invalidImport')); }
      };
      input.click();
    }

    saveRecords(){
      localStorage.setItem(STORAGE_RECORDS, JSON.stringify(this.records));
    }
    loadRecords(){
      try{
        const raw = localStorage.getItem(STORAGE_RECORDS);
        if(raw) this.records = JSON.parse(raw);
      }catch(e){ this.records = []; }
    }
    renderRecords(){
      this.loadRecords();
      const list = this.recordsList;
      list.innerHTML = '';
      if(this.records.length===0){ list.textContent = '‚Äî'; return; }
      // show last 10
      const last = this.records.slice(-10).reverse();
      for(const r of last){
        const row = document.createElement('div');
        row.style.display='flex'; row.style.justifyContent='space-between';
        row.innerHTML = `<div style="font-weight:700">${r.name}</div><div>${r.time}s</div><div style="color:var(--muted)">${new Date(r.date).toLocaleString()}</div>`;
        list.appendChild(row);
      }
    }

    clearStorage(){
      if(!confirm('–û—á–∏—Å—Ç–∏—Ç—å –≤—Å–µ –ª–æ–∫–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ?')) return;
      localStorage.removeItem(STORAGE_GAME);
      localStorage.removeItem(STORAGE_RECORDS);
      location.hash = '';
      this.records = [];
      this.renderRecords();
      this.announce('Storage cleared');
    }

    /* --------------------
       Replay functionality (basic)
       -------------------- */
    playReplay(){
      if(!this.game.moveLog || this.game.moveLog.length===0){ alert('No moves to replay'); return; }
      this.replayPlaying = true;
      this.replayOverlay.innerHTML = '‚ñ∂Ô∏è Replay';
      // create fresh game and apply moves with interval
      const snapshot = JSON.parse(JSON.stringify(this.game.toJSON()));
      const g = MinesGame.fromJSON(snapshot);
      // reset revealed/flags
      g.revealed = new Uint8Array(g.size);
      g.flagged = new Uint8Array(g.size);
      this.replayOverlay.style.display = 'flex';
      let idx = 0;
      const moves = this.game.moveLog.slice();
      const step = ()=>{
        if(idx>=moves.length){ this.replayPlaying = false; this.replayOverlay.innerHTML=''; this.onScroll(); return; }
        const m = moves[idx++];
        if(m.action==='open'){
          // ensure mines placed on first open if needed
          if(g.firstClick){ g.placeMines(m.idx); g.firstClick=false; }
          g.open(m.idx);
        } else if(m.action==='flag'){ g.flagged[m.idx]=m.state; }
        // copy to UI game for rendering of this step (but do not overwrite original)
        const temp = MinesGame.fromJSON(JSON.parse(JSON.stringify(g.toJSON())));
        this.renderReplayState(temp);
        setTimeout(step, 220);
      };
      step();
    }

    renderReplayState(tempGame){
      // render a snapshot without replacing main game
      for(const i of this.visibleCells){
        const node = this.cellCache.get(i);
        if(!node) continue;
        // set visuals according to tempGame state
        const revealed = tempGame.revealed[i], mined = tempGame.mined[i], flagged = tempGame.flagged[i];
        node.classList.toggle('revealed', !!revealed);
        node.classList.toggle('mine', !!(revealed && mined));
        node.innerHTML = '';
        if(!revealed){
          if(flagged===1) node.innerHTML = `<span class="marker">üö©</span>`;
          else if(flagged===2) node.innerHTML = `<span class="marker">?</span>`;
        } else {
          if(mined) node.innerHTML = `<span class="marker">üí£</span>`;
          else node.innerHTML = `<span class="marker">${tempGame.neighbors[i] || ''}</span>`;
        }
      }
    }

    /* --------------------
       Dev / Self-test (hidden)
       -------------------- */
    toggleDev(){ const elDev = el('#dev-selftest'); elDev.style.display = elDev.style.display === 'none' ? 'inline-flex' : 'none'; alert('Dev toggled'); }

    selfTest(){
      // basic tests: mine counts, neighbor sums, reveal mechanics
      let ok = true, msg = [];
      // test 1: generate and ensure mine count
      const g = new MinesGame(10,10,12);
      g.placeMines(0);
      const mines = Array.from(g.mined).reduce((a,b)=>a+b,0);
      if(mines!==12){ ok=false; msg.push('Mine count mismatch'); }
      // test 2: neighbor counts consistent
      for(let i=0;i<g.size;i++){
        if(g.mined[i]) continue;
        const [r,c] = g.rc(i);
        let cnt=0;
        for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){
          if(dr===0 && dc===0) continue;
          const nr=r+dr, nc=c+dc;
          if(g.inBounds(nr,nc) && g.mined[g.index(nr,nc)]) cnt++;
        }
        if(cnt !== g.neighbors[i]){ ok=false; msg.push('Neighbor mismatch at '+i); break; }
      }
      // test 3: flood fill doesn't recurse
      const g2 = new MinesGame(20,20,10);
      g2.placeMines(5);
      const zIndex = g2.neighbors.findIndex(n=>n===0 && !g2.mined[n]);
      if(zIndex>=0){
        const revealed = g2.revealIndex(zIndex);
        if(revealed.length===0) { ok=false; msg.push('Flood reveal failed'); }
      }
      alert('Self-test: ' + (ok ? 'OK' : 'FAIL') + (msg.length? '\n' + msg.join('\n') : ''));
    }

    /* --------------------
       Touch gestures (long press = flag; two-finger tap = flag)
       -------------------- */
    setupTouchHandlers(){
      let touchStart, touchIdx, longPressTimer;
      this.gridViewport.addEventListener('touchstart', (e)=>{
        if(e.touches.length===2){
          // two-finger tap: flag cell under first touch
          const touch = e.touches[0];
          const elNode = document.elementFromPoint(touch.clientX, touch.clientY);
          const node = elNode?.closest?.('.cell');
          if(node) this.handleFlagFromNode(parseInt(node.dataset.idx));
          e.preventDefault();
          return;
        }
        const t = e.touches[0];
        const target = document.elementFromPoint(t.clientX, t.clientY);
        const node = target?.closest?.('.cell');
        if(node){
          touchStart = Date.now();
          touchIdx = parseInt(node.dataset.idx);
          longPressTimer = setTimeout(()=>{ this.handleFlagFromNode(touchIdx); }, 600);
        }
      });
      this.gridViewport.addEventListener('touchend', (e)=>{
        clearTimeout(longPressTimer);
        // if short tap, open
        if(touchStart && Date.now()-touchStart < 400){
          if(touchIdx!=null) this.handleOpenFromNode(touchIdx);
        }
        touchStart = null; touchIdx = null;
      });
      this.gridViewport.addEventListener('touchmove', ()=>{ clearTimeout(longPressTimer); });
    }
  }

  // Instantiate UI
  const ui = new UI();

  // Expose minimal API for debugging (window.ms)
  window.ms = {
    ui, MinesGame
  };

  /* ============================================================================
     Notes in code:
     - Chosen hybrid approach: DOM grid with virtualization for accessibility and
       semantic roles. Canvas would be faster for pure rendering but harms a11y.
       Virtualization keeps DOM small for big fields (e.g., 100x100) while keeping
       cells accessible and focusable.
     - Flood-fill uses iterative stack to avoid recursion depth.
     - Rendering updates are batched by only updating visible cells.
     - All data stored locally in localStorage with versioned keys.
     - No external network calls or resources.
     ============================================================================
  */

})();
</script>
</body>
</html>
